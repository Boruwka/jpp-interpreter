-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Grammar.Par where
import Grammar.Abs
import Grammar.Lex
import Grammar.ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '+' { PT _ (TS _ 1) }
  ';' { PT _ (TS _ 2) }
  '=' { PT _ (TS _ 3) }
  'else' { PT _ (TS _ 4) }
  'if' { PT _ (TS _ 5) }
  'int' { PT _ (TS _ 6) }
  'then' { PT _ (TS _ 7) }
  L_ident  { PT _ (TV $$) }
  L_integ  { PT _ (TI $$) }

%%

Ident   :: { Ident }
Ident    : L_ident  { Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Expr :: { (Expr ()) }
Expr : Ident { Grammar.Abs.EVar () $1 }
     | Integer { Grammar.Abs.EInt () $1 }
     | Expr '+' Expr { Grammar.Abs.EAdd () $1 $3 }
Inst :: { (Inst ()) }
Inst : Ident '=' Expr { Grammar.Abs.IAssign () $1 $3 }
     | 'if' Expr 'then' Inst 'else' Inst { Grammar.Abs.IIf () $2 $4 $6 }
     | Type Ident '=' Expr { Grammar.Abs.IInit () $1 $2 $4 }
Type :: { (Type ()) }
Type : 'int' { Grammar.Abs.TypeInt () }
ListInst :: { [Inst ()] }
ListInst : {- empty -} { [] }
         | Inst { (:[]) $1 }
         | Inst ';' ListInst { (:) $1 $3 }
Program :: { (Program ()) }
Program : ListInst { Grammar.Abs.Prog () $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

