-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

module Grammar.Abs where

newtype Ident = Ident String
  deriving (Eq, Ord, Show, Read)

data Expr a
    = EVar a Ident | EInt a Integer | EAdd a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EVar a ident -> EVar (f a) ident
        EInt a integer -> EInt (f a) integer
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)

data Inst a
    = EAs a Ident (Expr a)
    | EIf a (Expr a) (Inst a) (Inst a)
    | EInit a (Type a) Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Inst where
    fmap f x = case x of
        EAs a ident expr -> EAs (f a) ident (fmap f expr)
        EIf a expr inst1 inst2 -> EIf (f a) (fmap f expr) (fmap f inst1) (fmap f inst2)
        EInit a type_ ident expr -> EInit (f a) (fmap f type_) ident (fmap f expr)

data Type a = TypeInt a
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TypeInt a -> TypeInt (f a)

data Program a = Prog a [Inst a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Prog a insts -> Prog (f a) (map (fmap f) insts)

